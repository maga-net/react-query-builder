{
  "readme_content": "# React Query Builder - Cross-Chain Bridge Event Listener\n\n> **Note on Naming:** Despite the repository name, this project is a backend service, not a UI component. It simulates the architectural logic of a decentralized bridge oracle.\n\nThis repository contains a Python-based simulation of a critical backend component for a cross-chain bridge: the **Event Listener and Validator Node**. The script is designed to monitor a source blockchain for specific events (e.g., `TokensLocked`), validate them, and then prepare and sign a corresponding transaction payload for a destination chain.\n\n## Concept\n\nCross-chain bridges allow users to transfer assets or data from one blockchain to another. A common architectural pattern is the \"lock-and-mint\" or \"burn-and-release\" mechanism. This script simulates the off-chain oracle or validator's role in this system.\n\n1.  **Listen**: The service continuously monitors a `Bridge` smart contract on the source chain (e.g., Ethereum).\n2.  **Detect**: It looks for a specific event, such as `TokensLocked`, which is emitted when a user deposits assets into the bridge contract, specifying a destination chain and recipient address.\n3.  **Confirm**: To mitigate the risk of block reorganizations (re-orgs), the service waits for a predefined number of `confirmation blocks` to pass before considering an event final.\n4.  **Validate & Attest**: Once confirmed, the service (acting as a validator) processes the event data. It creates a standardized payload containing the details of the transfer (amount, recipient, etc.) and signs it with its private key. This signature is an attestation, a verifiable proof that the event occurred on the source chain.\n5.  **Dispatch**: The signed payload is then dispatched to the destination chain. In a real system, this could be sent to a relayer network or directly submitted to a smart contract on the destination chain, which would then mint the equivalent tokens for the user.\n\n## Code Architecture\n\nThe script is designed with a modular, object-oriented approach to separate concerns and enhance maintainability.\n\n```\n+-----------------------+\n|  BridgeOrchestrator   | (Main loop, coordinates all components)\n+-----------+-----------+\n            |\n            | 1. Starts and manages\n            v\n+-----------------------+\n|     EventScanner      | (Scans source chain for events)\n+-----------+-----------+\n            |           |\n            |           | 2. Uses connector to get block data\n            |           v\n            |   +-----------------------+\n            |   |  BlockchainConnector  | (Manages Web3 connection)\n            |   +-----------------------+\n            |\n            | 3. Passes confirmed events to\n            v\n+-----------------------+\n|  TransactionProcessor | (Validates event data, creates payload)\n+-----------+-----------+\n            |\n            | 4. Passes payload to\n            v\n+-----------------------+\n| CrossChainDispatcher  | (Signs payload with validator key, sends to dest)\n+-----------------------+\n```\n\n### Core Components\n\n-   `BlockchainConnector`: A wrapper around `web3.py` to handle the connection to a specific blockchain's RPC endpoint. It is responsible for establishing and verifying the connection.\n-   `EventScanner`: The heart of the listening process. It polls the source chain for new blocks, queries for specific contract events within a block range, and waits for confirmations before flagging an event as final.\n-   `TransactionProcessor`: A pure logic class that takes a raw event log, validates its data (e.g., checks if it's intended for the correct destination chain), and transforms it into a structured, standardized payload.\n-   `CrossChainDispatcher`: Simulates the validator's role. It takes the processed payload, signs it using a private key, and dispatches the signed message. In this simulation, it sends the data to a mock API endpoint.\n-   `BridgeOrchestrator`: The top-level class that initializes and wires together all other components. It runs the main asynchronous loop, controlling the flow from scanning to dispatching.\n\n## How it Works\n\n1.  **Configuration**: The script loads its configuration from environment variables (using a `.env` file) and the `CONFIG` dictionary in `script.py`. This includes RPC URLs, contract addresses, and the validator's private key.\n\n2.  **Initialization**: The `BridgeOrchestrator` is instantiated. It creates instances of the `BlockchainConnector`, `EventScanner`, `TransactionProcessor`, and `CrossChainDispatcher` with the loaded configuration.\n\n3.  **Scanning Loop**: The orchestrator starts its `run()` method.\n    -   The `EventScanner` determines the range of blocks to scan, from the last scanned block up to the latest block minus the required number of confirmations.\n    -   It uses `web3.py` to filter for `TokensLocked` events within that block range.\n\n4.  **Processing**: If any confirmed events are found:\n    -   Each event is passed to the `TransactionProcessor`.\n    -   The processor checks if the event's `destinationChainId` matches the configured destination. If so, it creates a structured payload.\n\n5.  **Dispatching**: \n    -   The valid payload is passed to the `CrossChainDispatcher`.\n    -   The dispatcher serializes the payload, calculates its Keccak hash, and signs the hash with the validator's private key.\n    -   The signed message is then sent to a mock API endpoint to simulate the completion of the cross-chain communication leg.\n\n6.  **Repeat**: The orchestrator pauses for a configured interval (`poll_interval_seconds`) and then repeats the loop.\n\n## Getting Started\n\n### 1. Prerequisites\n\n-   Python 3.8+\n-   An RPC URL for a source EVM-compatible chain (e.g., from Infura, Alchemy for Sepolia testnet).\n-   A private key for the account that will act as the validator. **Do not use a key with real funds for this simulation.**\n\n### 2. Installation\n\nClone the repository and install the required dependencies:\n\n```bash\ngit clone <repository-url>\ncd react-query-builder\npip install -r requirements.txt\n```\n\n### 3. Configuration\n\nCreate a file named `.env` in the root of the project directory and add your configuration details. This file is ignored by Git to protect your secrets.\n\n```dotenv\n# .env file\n\n# RPC URL for the blockchain you want to listen to (e.g., Ethereum Sepolia)\nSOURCE_CHAIN_RPC_URL=\"https://sepolia.infura.io/v3/YOUR_INFURA_PROJECT_ID\"\n\n# (Optional) Address of the bridge contract on the source chain.\n# The default is a sample contract on the Sepolia testnet used for demonstration.\nSOURCE_BRIDGE_CONTRACT=\"0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\"\n\n# Private key of the account that will sign the attestations. \n# MUST start with 0x. USE A BURNER ACCOUNT.\nVALIDATOR_PRIVATE_KEY=\"0x_your_burner_private_key_here\"\n```\n\n### 4. Running the Script\n\nExecute the script from your terminal:\n\n```bash\npython script.py\n```\n\nThe script will start, connect to the source chain, and begin scanning for events. The console will show detailed log output of its operations.\n\n```\n# Example Output\n2023-10-27 15:30:00 - BridgeOrchestrator - [INFO] - Initializing Bridge Orchestrator...\n2023-10-27 15:30:01 - BlockchainConnector - [INFO] - Successfully connected to Ethereum-Sepolia (Chain ID: 11155111).\n2023-10-27 15:30:01 - EventScanner - [INFO] - Initializing bridge contract on Ethereum-Sepolia at 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\n2023-10-27 15:30:01 - TransactionProcessor - [INFO] - TransactionProcessor initialized for source 11155111 -> dest Polygon-Mumbai\n2023-10-27 15:30:01 - CrossChainDispatcher - [INFO] - Dispatcher initialized with validator address: 0x...\n2023-10-27 15:30:01 - BridgeOrchestrator - [INFO] - Bridge Event Listener service starting.\n2023-10-27 15:30:02 - EventScanner - [INFO] - Scanning Ethereum-Sepolia from block 4851200 to 4851210...\n2023-10-27 15:30:04 - BridgeOrchestrator - [INFO] - No new confirmed events found. Waiting for 10 seconds.\n... \n```"
}